// SPDX-License-Identifier: GPL-2.0-only
// Copyright (c) 2025-present FERS Contributors (see AUTHORS.md).

//! A safe Rust wrapper around the `libfers` C-style FFI.
//! This module handles resource management (via `Drop`) and safe string conversions.

use std::ffi::{CStr, CString};
use std::os::raw::c_char;

/// Inner module to encapsulate the raw, unsafe FFI bindings generated by `bindgen`.
mod ffi {
    #![allow(non_upper_case_globals)]
    #![allow(non_camel_case_types)]
    #![allow(non_snake_case)]
    #![allow(dead_code)]
    include!(concat!(env!("OUT_DIR"), "/bindings.rs"));
}

/// A wrapper for a C-style string returned from the `libfers` library.
/// It ensures that `fers_free_string` is called when the wrapper is dropped.
struct FersOwnedString(*mut c_char);

impl Drop for FersOwnedString {
    fn drop(&mut self) {
        if !self.0.is_null() {
            // SAFETY: The pointer was allocated by `libfers` and is valid until we call `fers_free_string`.
            // We are the sole owner of this pointer.
            unsafe { ffi::fers_free_string(self.0) };
        }
    }
}

impl FersOwnedString {
    /// Converts the owned C string to a Rust `String`, consuming the wrapper.
    /// Returns an error if the C string contains invalid UTF-8.
    fn into_string(self) -> Result<String, std::str::Utf8Error> {
        if self.0.is_null() {
            return Ok(String::new());
        }
        // SAFETY: `self.0` is a valid, null-terminated C string from `libfers`.
        // The `CStr::from_ptr` is safe as long as the pointer is valid.
        let c_str = unsafe { CStr::from_ptr(self.0) };
        c_str.to_str().map(|s| s.to_string())
    }
}

/// A safe wrapper for the `fers_context_t*` handle.
/// It automatically creates the context on initialization and destroys it on drop.
pub struct FersContext {
    // This must be a raw pointer because `fers_context_t` is an opaque struct.
    // The `Send` and `Sync` traits are manually implemented because we'll wrap this
    // context in a Mutex, ensuring that access to the non-thread-safe C++ object
    // is properly synchronized.
    ptr: *mut ffi::fers_context_t,
}

// SAFETY: The FersContext will be protected by a Mutex. All C-API calls on a single
// context are not guaranteed to be thread-safe by themselves, but by enforcing
// serialized access through a Mutex, we make its usage safe across threads.
unsafe impl Send for FersContext {}
unsafe impl Sync for FersContext {}

impl Drop for FersContext {
    fn drop(&mut self) {
        if !self.ptr.is_null() {
            // SAFETY: `self.ptr` is a valid handle created by `fers_context_create`.
            // The `Drop` trait ensures this is called exactly once.
            unsafe { ffi::fers_context_destroy(self.ptr) };
        }
    }
}

/// A helper function to retrieve and free the last error message from `libfers`.
fn get_last_error() -> String {
    // SAFETY: `fers_get_last_error_message` is a thread-safe FFI function.
    let error_ptr = unsafe { ffi::fers_get_last_error_message() };
    if error_ptr.is_null() {
        "An unknown FFI error occurred.".to_string()
    } else {
        // The FersOwnedString wrapper ensures the memory is freed.
        FersOwnedString(error_ptr)
            .into_string()
            .unwrap_or_else(|e| format!("FFI error message contained invalid UTF-8: {}", e))
    }
}

impl FersContext {
    /// Creates a new `FersContext`.
    /// Returns `None` if the C++ context creation fails.
    pub fn new() -> Option<Self> {
        // SAFETY: `fers_context_create` is a simple constructor function with no preconditions.
        let ptr = unsafe { ffi::fers_context_create() };
        if ptr.is_null() {
            None
        } else {
            Some(Self { ptr })
        }
    }

    /// Loads a scenario from an XML file path.
    pub fn load_scenario_from_xml_file(&self, filepath: &str) -> Result<(), String> {
        let c_filepath = CString::new(filepath).map_err(|e| e.to_string())?;
        // SAFETY: We pass a valid context pointer and a null-terminated C string.
        // The function returns 0 on success.
        let result =
            unsafe { ffi::fers_load_scenario_from_xml_file(self.ptr, c_filepath.as_ptr(), 1) };
        if result == 0 {
            Ok(())
        } else {
            Err(get_last_error())
        }
    }

    /// Deserializes the in-memory scenario to a JSON string.
    pub fn get_scenario_as_json(&self) -> Result<String, String> {
        // SAFETY: We pass a valid context pointer. The function returns a C string
        // that we must free.
        let json_ptr = unsafe { ffi::fers_get_scenario_as_json(self.ptr) };
        if json_ptr.is_null() {
            return Err(get_last_error());
        }
        // FersOwnedString takes ownership and will free the memory on drop.
        FersOwnedString(json_ptr)
            .into_string()
            .map_err(|e| e.to_string())
    }

    /// Deserializes the in-memory scenario to an XML string.
    pub fn get_scenario_as_xml(&self) -> Result<String, String> {
        // SAFETY: We pass a valid context pointer. The function returns a C string
        // that we must free.
        let xml_ptr = unsafe { ffi::fers_get_scenario_as_xml(self.ptr) };
        if xml_ptr.is_null() {
            return Err(get_last_error());
        }
        // FersOwnedString takes ownership and will free the memory on drop.
        FersOwnedString(xml_ptr)
            .into_string()
            .map_err(|e| e.to_string())
    }

    /// Updates the in-memory scenario from a JSON string.
    pub fn update_scenario_from_json(&self, json: &str) -> Result<(), String> {
        let c_json = CString::new(json).map_err(|e| e.to_string())?;
        // SAFETY: We pass a valid context pointer and a null-terminated C string.
        // The function returns 0 on success.
        let result = unsafe { ffi::fers_update_scenario_from_json(self.ptr, c_json.as_ptr()) };
        if result == 0 {
            Ok(())
        } else {
            Err(get_last_error())
        }
    }
}
