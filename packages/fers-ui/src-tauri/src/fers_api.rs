// SPDX-License-Identifier: GPL-2.0-only
// Copyright (c) 2025-present FERS Contributors (see AUTHORS.md).

//! # Safe Rust FFI Wrapper for `libfers`
//!
//! This module provides a safe, idiomatic Rust interface to the `libfers` C++
//! simulation library. It bridges the gap between the raw C-style FFI (generated
//! by `bindgen`) and the higher-level Rust code used in the Tauri application.
//!
//! ## Safety Guarantees
//!
//! The module ensures the following safety properties:
//!
//! 1. **Automatic Resource Management**: All C-allocated resources (contexts, strings)
//!    are wrapped in RAII types that guarantee cleanup via `Drop`.
//! 2. **Memory Safety**: Raw pointers from C are only dereferenced within `unsafe`
//!    blocks with documented safety invariants.
//! 3. **String Conversion**: All C strings are converted to Rust `String`s with
//!    proper UTF-8 validation and null-termination handling.
//! 4. **Thread Safety**: The `FersContext` is marked as `Send + Sync` because it
//!    will be protected by a `Mutex` in the application layer.
//!
//! ## Error Handling
//!
//! All fallible operations return `Result<T, String>`, where the error string
//! contains a human-readable message retrieved from the C library's thread-local
//! error storage.

use std::ffi::{CStr, CString};
use std::os::raw::c_char;

/// Raw FFI bindings generated by `bindgen` from `libfers/api.h`.
///
/// This inner module is kept private to prevent direct access to unsafe FFI
/// functions. It contains the raw C function declarations and opaque struct types
/// that mirror the C-API header.
///
/// # Safety
///
/// All items in this module are `unsafe` to use directly. They require:
/// * Valid, non-null pointers for all context handles.
/// * Proper null-termination for all C strings.
/// * Manual memory management (allocation/deallocation).
///
/// The parent module (`fers_api`) provides safe wrappers that enforce these invariants.
mod ffi {
    #![allow(non_upper_case_globals)]
    #![allow(non_camel_case_types)]
    #![allow(non_snake_case)]
    #![allow(dead_code)]
    include!(concat!(env!("OUT_DIR"), "/bindings.rs"));
}

/// A smart pointer wrapper for C-allocated strings returned from `libfers`.
///
/// This type ensures that the memory allocated by the C library (via `strdup`)
/// is properly freed when the wrapper goes out of scope, preventing memory leaks.
///
/// # Memory Management
///
/// The wrapped pointer must have been allocated by a `libfers` API function that
/// transfers ownership to the caller (e.g., `fers_get_scenario_as_json`). The
/// `Drop` implementation calls `fers_free_string` to release the memory back to
/// the C allocator.
///
/// # Null Handling
///
/// If the pointer is null, the wrapper treats it as an empty string. This simplifies
/// error handling in cases where null indicates "no data" rather than an error.
struct FersOwnedString(*mut c_char);

impl Drop for FersOwnedString {
    /// Frees the underlying C string by calling `fers_free_string`.
    ///
    /// This is automatically invoked when the wrapper goes out of scope,
    /// ensuring that no manual cleanup is required by the caller.
    ///
    /// # Safety
    ///
    /// The pointer must have been allocated by `libfers` (typically via `strdup`)
    /// and must not have been freed already. The `Drop` trait ensures this is
    /// called exactly once per instance.
    fn drop(&mut self) {
        if !self.0.is_null() {
            // SAFETY: The pointer was allocated by `libfers` and is valid until we call `fers_free_string`.
            // We are the sole owner of this pointer.
            unsafe { ffi::fers_free_string(self.0) };
        }
    }
}

impl FersOwnedString {
    /// Converts the owned C string to a Rust `String`, consuming the wrapper.
    ///
    /// This method performs UTF-8 validation and copies the string data into a
    /// Rust-managed `String`. The C-allocated memory is freed after the conversion.
    ///
    /// # Returns
    ///
    /// * `Ok(String)` - The converted string if valid UTF-8.
    /// * `Err(std::str::Utf8Error)` - If the C string contains invalid UTF-8 bytes.
    ///
    /// # Example
    ///
    /// ```no_run
    /// let owned = FersOwnedString(some_c_string_ptr);
    /// match owned.into_string() {
    ///     Ok(s) => println!("Got string: {}", s),
    ///     Err(e) => eprintln!("Invalid UTF-8: {}", e),
    /// }
    /// ```
    fn into_string(self) -> Result<String, std::str::Utf8Error> {
        if self.0.is_null() {
            return Ok(String::new());
        }
        // SAFETY: `self.0` is a valid, null-terminated C string from `libfers`.
        // The `CStr::from_ptr` is safe as long as the pointer is valid.
        let c_str = unsafe { CStr::from_ptr(self.0) };
        c_str.to_str().map(|s| s.to_string())
    }
}

/// A safe, RAII-style wrapper for the `fers_context_t*` C handle.
///
/// This struct encapsulates the lifetime and ownership of a simulation context
/// created by the `libfers` C++ library. It ensures that:
/// * The context is created via `fers_context_create` on initialization.
/// * The context is destroyed via `fers_context_destroy` when dropped.
/// * The context is never null after successful creation.
///
/// # Thread Safety
///
/// This type implements `Send` and `Sync` because the underlying C++ context will
/// be protected by a `Mutex` in the Tauri application. The C++ `FersContext` class
/// is not thread-safe, but by serializing all access through Rust's `Mutex`, we
/// ensure that only one thread can call methods on the context at a time.
///
/// # Example
///
/// ```no_run
/// use fers_api::FersContext;
///
/// let context = FersContext::new().expect("Failed to create context");
/// context.load_scenario_from_xml_file("scenario.xml")?;
/// let json = context.get_scenario_as_json()?;
/// // Context is automatically destroyed when it goes out of scope
/// ```
pub struct FersContext {
    /// The raw pointer to the C++ context object.
    ///
    /// This must be a raw pointer because `fers_context_t` is an opaque struct.
    /// The `Send` and `Sync` traits are manually implemented because we'll wrap this
    /// context in a Mutex, ensuring that access to the non-thread-safe C++ object
    /// is properly synchronized.
    ptr: *mut ffi::fers_context_t,
}

// SAFETY: The FersContext will be protected by a Mutex. All C-API calls on a single
// context are not guaranteed to be thread-safe by themselves, but by enforcing
// serialized access through a Mutex, we make its usage safe across threads.
unsafe impl Send for FersContext {}
unsafe impl Sync for FersContext {}

impl Drop for FersContext {
    /// Destroys the underlying C++ context and frees all associated resources.
    ///
    /// This method is automatically called when the `FersContext` goes out of scope.
    /// It delegates to `fers_context_destroy`, which is responsible for cleaning up
    /// the C++ `FersContext` object and its owned `World`.
    ///
    /// # Safety
    ///
    /// The pointer must be valid and non-null. The `Drop` trait guarantees this is
    /// called exactly once, preventing double-free errors.
    fn drop(&mut self) {
        if !self.ptr.is_null() {
            // SAFETY: `self.ptr` is a valid handle created by `fers_context_create`.
            // The `Drop` trait ensures this is called exactly once.
            unsafe { ffi::fers_context_destroy(self.ptr) };
        }
    }
}

/// Retrieves and formats the last error message from the `libfers` C-API.
///
/// This helper function is called whenever a C-API function returns an error code.
/// It queries the thread-local error storage via `fers_get_last_error_message`,
/// converts the C string to a Rust `String`, and ensures the memory is freed.
///
/// # Returns
///
/// A human-readable error message. If no error message is available (null pointer),
/// a default message is returned. If the error message contains invalid UTF-8, an
/// error describing the UTF-8 issue is returned instead.
///
/// # Thread Safety
///
/// This function is thread-safe because the error storage in `libfers` is thread-local.
/// Each thread has its own error message buffer.
fn get_last_error() -> String {
    // SAFETY: `fers_get_last_error_message` is a thread-safe FFI function.
    let error_ptr = unsafe { ffi::fers_get_last_error_message() };
    if error_ptr.is_null() {
        "An unknown FFI error occurred.".to_string()
    } else {
        // The FersOwnedString wrapper ensures the memory is freed.
        FersOwnedString(error_ptr)
            .into_string()
            .unwrap_or_else(|e| format!("FFI error message contained invalid UTF-8: {}", e))
    }
}

impl FersContext {
    /// Creates a new `FersContext` by calling the C-API constructor.
    ///
    /// This function allocates a new C++ `FersContext` object on the heap via
    /// `fers_context_create`. The returned context is initially empty and must be
    /// populated by loading a scenario (via `load_scenario_from_xml_file` or
    /// `update_scenario_from_json`).
    ///
    /// # Returns
    ///
    /// * `Some(FersContext)` - If the context was successfully created.
    /// * `None` - If allocation failed (e.g., out of memory) or if the C++ constructor
    ///   threw an exception.
    ///
    /// # Example
    ///
    /// ```no_run
    /// let context = FersContext::new().expect("Failed to create FERS context");
    /// ```
    pub fn new() -> Option<Self> {
        // SAFETY: `fers_context_create` is a simple constructor function with no preconditions.
        let ptr = unsafe { ffi::fers_context_create() };
        if ptr.is_null() {
            None
        } else {
            Some(Self { ptr })
        }
    }

    /// Loads a FERS scenario from an XML file into the context.
    ///
    /// This method replaces any existing scenario in the context with the one parsed
    /// from the specified file. The XML is validated against the FERS schema if
    /// validation is enabled in the C++ library.
    ///
    /// # Parameters
    ///
    /// * `filepath` - A UTF-8 string containing the absolute or relative path to the
    ///   FERS XML scenario file.
    ///
    /// # Returns
    ///
    /// * `Ok(())` - If the scenario was successfully loaded and parsed.
    /// * `Err(String)` - If the file could not be read, the XML was invalid, or a
    ///   C++ exception was thrown. The error string contains details.
    ///
    /// # Example
    ///
    /// ```no_run
    /// context.load_scenario_from_xml_file("/path/to/scenario.xml")?;
    /// ```
    pub fn load_scenario_from_xml_file(&self, filepath: &str) -> Result<(), String> {
        let c_filepath = CString::new(filepath).map_err(|e| e.to_string())?;
        // SAFETY: We pass a valid context pointer and a null-terminated C string.
        // The function returns 0 on success.
        let result =
            unsafe { ffi::fers_load_scenario_from_xml_file(self.ptr, c_filepath.as_ptr(), 1) };
        if result == 0 {
            Ok(())
        } else {
            Err(get_last_error())
        }
    }

    /// Retrieves the current in-memory scenario as a JSON string.
    ///
    /// This method serializes the C++ `World` object into JSON format, which mirrors
    /// the structure used by the frontend. It is typically used to populate the UI
    /// after loading a scenario from XML.
    ///
    /// # Returns
    ///
    /// * `Ok(String)` - The JSON representation of the scenario.
    /// * `Err(String)` - If serialization failed or the JSON contains invalid UTF-8.
    ///
    /// # Memory Management
    ///
    /// The returned string is a Rust-owned `String`. The underlying C-allocated memory
    /// is automatically freed by the `FersOwnedString` wrapper.
    ///
    /// # Example
    ///
    /// ```no_run
    /// let json = context.get_scenario_as_json()?;
    /// let scenario: serde_json::Value = serde_json::from_str(&json)?;
    /// ```
    pub fn get_scenario_as_json(&self) -> Result<String, String> {
        // SAFETY: We pass a valid context pointer. The function returns a C string
        // that we must free.
        let json_ptr = unsafe { ffi::fers_get_scenario_as_json(self.ptr) };
        if json_ptr.is_null() {
            return Err(get_last_error());
        }
        // FersOwnedString takes ownership and will free the memory on drop.
        FersOwnedString(json_ptr)
            .into_string()
            .map_err(|e| e.to_string())
    }

    /// Retrieves the current in-memory scenario as a FERS XML string.
    ///
    /// This method serializes the C++ `World` object into the standard FERS XML format.
    /// It is typically used when the user wants to export the scenario (potentially
    /// modified in the UI) back to a file.
    ///
    /// # Returns
    ///
    /// * `Ok(String)` - The XML representation of the scenario.
    /// * `Err(String)` - If serialization failed or the XML contains invalid UTF-8.
    ///
    /// # Memory Management
    ///
    /// The returned string is a Rust-owned `String`. The underlying C-allocated memory
    /// is automatically freed by the `FersOwnedString` wrapper.
    ///
    /// # Example
    ///
    /// ```no_run
    /// let xml = context.get_scenario_as_xml()?;
    /// std::fs::write("exported_scenario.xml", xml)?;
    /// ```
    pub fn get_scenario_as_xml(&self) -> Result<String, String> {
        // SAFETY: We pass a valid context pointer. The function returns a C string
        // that we must free.
        let xml_ptr = unsafe { ffi::fers_get_scenario_as_xml(self.ptr) };
        if xml_ptr.is_null() {
            return Err(get_last_error());
        }
        // FersOwnedString takes ownership and will free the memory on drop.
        FersOwnedString(xml_ptr)
            .into_string()
            .map_err(|e| e.to_string())
    }

    /// Updates the in-memory scenario from a JSON string.
    ///
    /// This method is the primary way for the UI to push modified scenario data back
    /// to the C++ simulation engine. It deserializes the JSON and rebuilds the internal
    /// `World` object, replacing any existing scenario.
    ///
    /// # Parameters
    ///
    /// * `json` - A UTF-8 JSON string representing the scenario. The structure must
    ///   match the schema expected by `libfers` (the same format returned by
    ///   `get_scenario_as_json`).
    ///
    /// # Returns
    ///
    /// * `Ok(())` - If the scenario was successfully deserialized and loaded.
    /// * `Err(String)` - If the JSON was malformed, contained invalid data, or a C++
    ///   exception was thrown. The error string contains details.
    ///
    /// # Example
    ///
    /// ```no_run
    /// let modified_json = /* JSON from UI */;
    /// context.update_scenario_from_json(&modified_json)?;
    /// ```
    pub fn update_scenario_from_json(&self, json: &str) -> Result<(), String> {
        let c_json = CString::new(json).map_err(|e| e.to_string())?;
        // SAFETY: We pass a valid context pointer and a null-terminated C string.
        // The function returns 0 on success.
        let result = unsafe { ffi::fers_update_scenario_from_json(self.ptr, c_json.as_ptr()) };
        if result == 0 {
            Ok(())
        } else {
            Err(get_last_error())
        }
    }

    /// Runs the simulation defined in the context.
    ///
    /// This is a blocking call that executes the simulation on a separate thread pool
    /// managed by the C++ core.
    ///
    /// # Returns
    ///
    /// * `Ok(())` - If the simulation completed successfully.
    /// * `Err(String)` - If the simulation failed.
    pub fn run_simulation(&self) -> Result<(), String> {
        // SAFETY: We pass a valid context pointer. The function is synchronous.
        // The `user_data` pointer is null as it's currently unused.
        let result = unsafe { ffi::fers_run_simulation(self.ptr, std::ptr::null_mut()) };
        if result == 0 {
            Ok(())
        } else {
            Err(get_last_error())
        }
    }

    /// Generates a KML file for the current scenario.
    ///
    /// # Parameters
    ///
    /// * `output_path` - The path where the KML file will be saved.
    ///
    /// # Returns
    ///
    /// * `Ok(())` - If the KML file was generated successfully.
    /// * `Err(String)` - If KML generation failed.
    pub fn generate_kml(&self, output_path: &str) -> Result<(), String> {
        let c_output_path = CString::new(output_path).map_err(|e| e.to_string())?;
        // SAFETY: We pass a valid context pointer and a null-terminated C string for the path.
        let result = unsafe { ffi::fers_generate_kml(self.ptr, c_output_path.as_ptr()) };
        if result == 0 {
            Ok(())
        } else {
            Err(get_last_error())
        }
    }
}
