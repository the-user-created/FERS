//rsresponse.h
// Classes for responses created by simulation
// Marc Brooker mbrooker@rrsg.ee.uct.ac.za
// 3 August 2006
#ifndef __RSRESPONSE_H
#define __RSRESPONSE_H

#include <config.h>
#include <vector>
#include <string>
#include "rsradarwaveform.h"
#include <boost/utility.hpp>
#include <boost/shared_array.hpp>
#include <iosfwd>

//Forward declaration of TiXmlElement (see tinyxml.h)
class TiXmlElement;

namespace rs {

  //Forward definition of Antenna (see rsantenna.h)
  class Antenna;
  //Forward definition of Transmitter (in this file)
  class Transmitter;
 
  /// Base class for both pulsed and CW responses
  class ResponseBase: boost::noncopyable {
  public:
    enum ResponseType { RS_PULSED, RS_CONTINUOUS };
    /// Constructor
    ResponseBase(rsFloat start, const Transmitter *transmitter);
    /// Get the start time
    rsFloat GetStart() const;
    /// Destructor
    virtual ~ResponseBase();
    /// Render the response to an XML file
    virtual void RenderXML(TiXmlElement *root) = 0;
    /// Render the response to a CSV file
    virtual void RenderCSV(std::ofstream &of) = 0;
    /// Render the deadtime to an XML file
    virtual void RenderDeadtimeXML(TiXmlElement *root);
    /// Render the response to a binary file
    virtual boost::shared_array<rsComplex> RenderBinary(rsFloat& rate, unsigned int &size) = 0;
    /// Get the length of the pulse
    virtual rsFloat GetLength() const = 0;
    /// Get a pointer to the wave
    virtual const rs::RadarWaveform* GetWave() const = 0;
    /// Add a receiver deadtime pair (start of deadtime, end of deadtime)
    virtual void AddDeadTime(std::pair<rsFloat, rsFloat> pair);
    /// Get the name of the transmitter that started this response
    std::string GetTransmitterName() const;
    /// Return the type of the response
    virtual ResponseType Type() const = 0;
  protected:
    rsFloat start; //!< Start time (seconds)
    const Transmitter *transmitter; //!< The transmitter that caused this response
    std::vector<std::pair<rsFloat, rsFloat> > deadtime; //!< Receive deadtime due to T-R switching
  };

  /// The response struct contains the response the receiver sees of a target illuminated by a transmitter
  class Response: public rs::ResponseBase {
  public:
    /// Constructor
    Response(const rs::RadarWaveform *wave, rsFloat start, rsFloat amplitude, rsFloat phase, rsFloat doppler, rsFloat noise_temperature, const Transmitter *transmitter);
    /// Destructor
    ~Response();
    /// Return the time the pulse's energy starts
    rsFloat StartTime() const;
    /// Return the time the pulse's energy ends
    rsFloat EndTime() const;
    /// Render the response to an XML file
    void RenderXML(TiXmlElement *element);
    /// Render the response to a CSV file
    void RenderCSV(std::ofstream &of);
    /// Render the response to a binary file
    boost::shared_array<rsComplex> RenderBinary(rsFloat& rate, unsigned int &size);
    /// Get the length of the pulse
    rsFloat GetLength() const;
    /// Get a pointer to the wave
    const rs::RadarWaveform* GetWave() const;
    /// Return the Response type
    ResponseType Type() const;
  private:
    const rs::RadarWaveform *wave; //!< The pulse sent out by the transmitter
    rsFloat amplitude; //!< Amplitude change introduced by distance (linear)
    rsFloat phase; //!< Phase shift caused by delay
    rsFloat doppler; //!< Frequency shift caused by doppler effect (Hertz) (non-linear)
    rsFloat noise_temperature; //!< The system noise temperature seen by the response
    bool range_error; //!< A range error has occured    
  };

  /// The CWResponse struct contains a response generated by a continuous wave transmitter
  class CWResponse: public rs::ResponseBase {
  public:
    /// Default Constructor
    CWResponse(const rs::RadarWaveform* wave, rsFloat start, const Transmitter *transmitter);
    /// Destructor
    ~CWResponse();
    /// Render the response to an XML file
    void RenderXML(TiXmlElement *root);
    /// Render the response to a CSV file
    void RenderCSV(std::ofstream &of);
    /// Render the response to a binary file
    boost::shared_array<rsComplex> RenderBinary(rsFloat& rate, unsigned int &size);
    /// Render the interpolation points to a binary format
    const std::vector<CWInterpPoint>& GetPoints() const;
    /// Get the length of the pulse
    rsFloat GetLength() const;
    /// Get a pointer to the wave
    const rs::RadarWaveform* GetWave() const;
    /// Add an interp point
    void AddInterpPoint(CWInterpPoint &point);
    /// Return the Response type
    ResponseType Type() const;
  private:
    void RenderResponseXML(TiXmlElement *root, const CWInterpPoint &point);
    void RenderResponseCSV(std::ofstream &of, const CWInterpPoint &point); //!< Render a CWInterpPoint as CSV
    const rs::RadarWaveform *wave; //!< The CW waveform sent out by the transmitter
    std::vector<CWInterpPoint> points; //!< Waypoints from which the CW response is interpolated
  };

}

#endif
