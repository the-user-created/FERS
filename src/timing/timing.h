/**
* @file timing.h
* @brief Timing source for simulation objects.
*
* This file defines the `Timing` class, which represents a timing source for simulations.
* The class is responsible for managing the timing source, providing sample values,
* and ensuring synchronization of objects in a simulation with the timing source.
* All objects must adhere to a common timing source, which is modeled and adjusted by the methods in this class.
*
* The timing source uses noise generators to model clock behavior
* and provides the ability to skip samples and reset the model.
* It is designed to be initialized with prototype timing data and cannot be copied.
*
* @authors David Young, Marc Brooker
* @date 2006-10-16
*/

#pragma once

#include <memory>
#include <string>
#include <utility>
#include <vector>

#include "config.h"
#include "noise/noise_generators.h"

namespace timing
{
	class PrototypeTiming;

	/**
	* @class Timing
	* @brief Represents a timing source for simulation.
	*
	* The `Timing` class models a timing source used in simulations.
	* It manages timing samples, synchronization, and frequency information,
	* and interacts with a noise generator to simulate clock behavior.
	* It ensures that all objects using this timing source stay synchronized.
	*/
	class Timing final
	{
	public:
		/**
		* @brief Constructs a Timing object.
		*
		* Initializes the timing source with a given name.
		*
		* @param name The name of the timing source.
		*/
		explicit Timing(std::string name) noexcept : _name(std::move(name)) {}

		/**
		* @brief Destructor for Timing.
		*
		* Cleans up the Timing object.
		*/
		~Timing() = default;

		/**
		* @brief Deleted copy constructor.
		*
		* The Timing object cannot be copied.
		*/
		Timing(const Timing&) = delete;

		/**
		* @brief Deleted copy assignment operator.
		*
		* Prevents copying of the Timing object.
		*
		* @return Reference to the current object.
		*/
		Timing& operator=(const Timing&) = delete;

		/**
		* @brief Gets the next sample from the timing source.
		*
		* Retrieves the next sample value generated by the timing model if the timing source is enabled.
		* If the timing source is not enabled, returns 0.0f.
		*
		* @return The next sample value or 0.0f if not enabled.
		*/
		[[nodiscard]] RealType getNextSample() const noexcept { return _enabled ? _model->getSample() : 0.0f; }

		/**
		* @brief Gets the name of the timing source.
		*
		* Retrieves the name of this timing source.
		*
		* @return The name of the timing source.
		*/
		[[nodiscard]] std::string getName() const noexcept { return _name; }

		/**
		* @brief Checks if the timing source synchronizes on pulse.
		*
		* Determines whether the timing source is configured to synchronize on pulse.
		*
		* @return True if synchronized on pulse, otherwise false.
		*/
		[[nodiscard]] bool getSyncOnPulse() const noexcept { return _sync_on_pulse; }

		/**
		* @brief Gets the frequency of the timing source.
		*
		* Retrieves the frequency of the timing source.
		*
		* @return The frequency of the timing source.
		*/
		[[nodiscard]] RealType getFrequency() const noexcept { return _frequency; }

		/**
		* @brief Checks if the timing source is enabled.
		*
		* Determines if the timing source and its model are enabled and functioning.
		*
		* @return True if enabled, otherwise false.
		*/
		[[nodiscard]] bool isEnabled() const noexcept { return _enabled && _model && _model->enabled(); }

		// Note: This function is not used in the codebase
		/*[[nodiscard]] RealType getPulseTimeError() const noexcept {
			return _enabled && _model ? _model->getSample() : 0.0f;
		}*/

		/**
		* @brief Skips a number of samples in the timing model.
		*
		* Skips the specified number of samples in the timing source if it is enabled.
		*
		* @param samples The number of samples to skip.
		*/
		void skipSamples(long long samples) const noexcept;

		/**
		* @brief Initializes the timing model.
		*
		* Initializes the timing model using the provided prototype timing configuration.
		* Copies frequency and phase information from the prototype.
		*
		* @param timing The prototype timing configuration used for initialization.
		*/
		void initializeModel(const PrototypeTiming* timing) noexcept;

		/**
		* @brief Resets the timing model.
		*
		* Resets the internal timing model, if it is initialized.
		*/
		void reset() const noexcept { if (_model) { _model->reset(); } }

	private:
		std::string _name; ///< The name of the timing source.
		bool _enabled{false}; ///< Flag indicating if the timing source is enabled.
		std::unique_ptr<noise::ClockModelGenerator> _model{nullptr};
		///< The noise generator model for the timing source.
		std::vector<RealType> _alphas; ///< The alpha values for the noise generator model.
		std::vector<RealType> _weights; ///< The weights for the noise generator model.
		RealType _frequency{}; ///< The frequency of the timing source.
		bool _sync_on_pulse{false}; ///< Flag indicating if the timing source synchronizes on pulse.
	};
}
